function F = FeatureMap(img,GFB,varargin)
% FUNCTION generates feature map F~ from image and Gabor filter bank
%
%   F = FeatureMap(img,GFB)
%   F = FeatureMap(img,GFB,normalize)
%   F = FeatureMap(img,GFB,normalize,filter_domain)
%
% INPUT :
%	img - input grayscale image in double format
%	GFB  - Gabor filter bank as generated by function GaborFilterBank()
%   normalize - boolean value defining whether a per-pixel normalisation
%   should be done or not (default: true)
%   filter_domain - domain where filtering is performed: 'spatial' or
%   'frequency' (default: 'frequency' as it is way faster)
%
% OUTPUT :
%	F - Feature map F~ of size R x C x M x N, where R is the number of rows of img, C is the number of columns of img, N is the number of
%	orientations and M is the number of scales
%

if nargin==4
    normalize = varargin{1};
    filter_domain = varargin{2};
elseif nargin==3
    normalize = varargin{1};
    filter_domain = 'frequency';
else
    normalize = true;
    filter_domain = 'frequency';
end

nr_scales = length(GFB.scale);
nr_orientations = length(GFB.scale(1).orient);
F = zeros(size(img,1),size(img,2),nr_scales,nr_orientations);

if strcmp(filter_domain,'spatial')
    for j = 1:nr_scales
        for k = 1:nr_orientations
          F(:,:,j,k) = abs(imfilter(img,GFB.scale(j).orient(k).spatial,'same','replicate'));
        end
    end
end


if strcmp(filter_domain,'frequency')
    img_F = fft2(img);
    for j = 1:nr_scales
        for k = 1:nr_orientations
            out = abs(ifft2(img_F .* GFB.scale(j).orient(k).frequency));
            %shift by offset 
            F(:,:,j,k) = circshift(out,[GFB.scale(j).orient(k).offset]);
        end
    end
end




if normalize
    %avoid zero values to prevent division by null
    t=0.000000000001;
    F(F<t)=t;
    F = F./repmat(sqrt(sum(sum(F.^2,4),3)),[1 1 nr_scales nr_orientations]);
end



